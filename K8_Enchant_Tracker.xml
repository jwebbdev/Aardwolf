<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Tuesday, October 22, 2024, 9:56 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "K8_Enchant_Tracker" generated by Plugin Wizard -->

<muclient>
<plugin
   name="K8_Enchant_Tracker"
   author="Kindahlin"
   id="c53e36222e82c5c39e54d98e"
   language="Lua"
   purpose="Track Enchanting Data"
   save_state="y"
   date_written="2024-10-22 21:54:49"
   requires="5.07"
   version="1.0"
   >

</plugin>


<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   match="^{enchant_cast_(?<type>\S+)_(?<item>\S+)}$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="on_enchant_cast_start"
  >
  </trigger>
  <trigger
   group="capture_enchant_success"
   match="You lost your concentration while trying to cast *"
   send_to="12"
   sequence="100"
   script="on_enchant_fizzle"
  >
  </trigger>
  <trigger
   enabled="y"
   group="capture_enchant_success"
   match="Magic pulses through *"
   send_to="12"
   sequence="100"
   script="on_enchant_success"
  >
  </trigger>
  <trigger
   enabled="y"
   match="^{/enchant_cast_(?<type>\S+)_(?<item>\S+)}$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="on_enchant_cast_end"
  >
  </trigger>
  <trigger
   enabled="y"
   match="{solidify_id}"
   send_to="12"
   sequence="100"
  >
  <send>EnableTriggerGroup("solidify_id", 1)</send>
  </trigger>
  <trigger
   enabled="y"
   match="{/solidify_id}"
   send_to="12"
   sequence="100"
   script="on_capture_solidify_end"
  >
  </trigger>
  <trigger
   group="solidify_id"
   match="^\| Solidify   \: (?<type>Damage roll|Hit roll) \+(?<value>\d+).*$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="on_capture_solidify"
  >
  </trigger>
  <trigger
   enabled="y"
   match="{illuminate_id}"
   send_to="12"
   sequence="100"
  >
  <send>EnableTriggerGroup("illuminate_id", 1)</send>
  </trigger>
  <trigger
   enabled="y"
   match="{/illuminate_id}"
   send_to="12"
   sequence="100"
   script="on_capture_illuminate_end"
  >
  </trigger>
  <trigger
   group="illuminate_id"
   match="^\| Illuminate \: (?<type>Luck|Wisdom) \+(?<value>\d+).*$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="on_capture_illuminate"
  >
  </trigger>
  <trigger
   group="illuminate_id"
   match="^\|            \: (?<type>Wisdom) \+(?<value>\d+).*$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="on_capture_illuminate"
  >
  </trigger>
  <trigger
   enabled="y"
   match="{resonate_id}"
   send_to="12"
   sequence="100"
  >
  <send>EnableTriggerGroup("resonate_id", 1)</send>
  </trigger>
  <trigger
   enabled="y"
   match="{/resonate_id}"
   send_to="12"
   sequence="100"
   script="on_capture_resonate_end"
  >
  </trigger>
  <trigger
   group="resonate_id"
   match="^\|            \: (?<type>Luck) \+(?<value>\d+).*$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="on_capture_resonate"
  >
  </trigger>
  <trigger
   group="resonate_id"
   match="^\| Resonate   \: (?<type>Strength|Intelligence|Wisdom|Dexterity|Constitution|Luck) \+(?<value>\d+).*$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="on_capture_resonate"
  >
  </trigger>
  <trigger
   enabled="y"
   match="{enchant_check_focus}"
   send_to="12"
   sequence="100"
   script="on_enchanters_focus_start"
  >
  </trigger>
  <trigger
   group="enchanters_focus"
   match="^  Enchanters focus         : (?<percent>\d+)% enchanters focus.*$"
   regexp="y"
   send_to="12"
   sequence="100"
   script="on_capture_enchanters_focus"
  >
  </trigger>
  <trigger
   enabled="y"
   match="{/enchant_check_focus}"
   send_to="12"
   sequence="100"
   script="on_enchanters_focus_end"
  >
  </trigger>
  <trigger
   enabled="y"
   match="{enchant_failure}"
   send_to="12"
   sequence="100"
   script="on_enchant_failure"
  >
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   match="^track illuminate (?<item>\S+)$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="on_track_illuminate"
  >
  </alias>
  <alias
   match="^track resonate (?<item>\S+)$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="on_track_resonate"
  >
  </alias>
  <alias
   match="^track solidify (?<item>\S+)$"
   regexp="y"
   enabled="y"
   sequence="100"
   script="on_track_solidify"
  >
  </alias>
  <alias
   match="track moons"
   enabled="y"
   sequence="100"
   script="set_moon_data"
  >
  </alias>
</aliases>

<script>
<![CDATA[
--[[
   -- Description --
--]]

require('gmcphelper')

function OnPluginInstall()
	OnPluginEnabled()
end

function OnPluginEnabled()
	OnPluginConnect()
end

function OnPluginConnect()
	Note("Time to load")
    dbLoad()
	reset_active_enchant()
end

function OnPluginDisconnect()
    dbSave()
    dbClose()
end

function OnPluginSaveState()
    dbSave()
end

-- Nice Query
-- select count(*) as total, type, (black_moon + white_moon + grey_moon) as moons, avg(luck + wisdom + intelligence + strength + dexterity + constitution) as total_stats, focus from enchantments where (type = 'resonate' or type = 'illuminate') and caster_int = 600 and caster_luck = 600 and caster_wis = 600 and success=1 group by moons, focus, type order by type, moons, focus;

------ DB ------
db_filename = "k8et.db"
db_version = 1
db = nil

function dbOpen()
    local filename = GetPluginInfo(GetPluginID(), 20) .. db_filename
    db = assert(sqlite3.open(filename))
    db:busy_timeout(100)
end

function dbNrowsExec(query)
    local ok, iter, vm, i = pcall(db.nrows, db, query)

    local count = 0
    while (not ok) and (count < db_max_retries) do
        local code = db:errcode()
        if (code ~= sqlite3.BUSY) and (code ~= sqlite3.LOCKED) then
            break
        end
        db:exec("ROLLBACK")
        local socket = require "socket"
        socket.sleep(db_sleep_duration)
        ok, iter, vm, i = pcall(db.nrows, db, query)
        count = count + 1
    end

    dbCheck(db:errcode(), db:errmsg(), query)

    local function itwrap(vm, i)
        retval = iter(vm, i)
        if not retval then
            return nil
        end
        return retval
    end
    return itwrap, vm, i
end

function dbLoad()
    if db ~= nil and db:isopen() then
        return
    end

	dbOpen()

	dbCheckExecute("PRAGMA journal_mode=WAL;")
    local db_user_version = 0
    for row in dbNrowsExec("PRAGMA user_version") do
        db_user_version = row.user_version
    end

    Note("Opened DB version " .. db_user_version)

    if db_user_version ~= db_version then
        dbUpdateVersion(db_user_version)
    end
end

function dbUpdateVersion(version)
    Note("Updating DB from version " .. version)
    if version == 0 then
        local sql = [[
      PRAGMA foreign_keys = ON;

      CREATE TABLE IF NOT EXISTS enchantments (
        enchant_id     INTEGER PRIMARY KEY AUTOINCREMENT,
        type           TEXT NOT NULL,      -- Set when alias entered
        success        BOOLEAN NOT NULL,   -- Set when enchantment is cast
        black_moon     BOOLEAN NOT NULL,   -- Set when enchantment is cast
        white_moon     BOOLEAN NOT NULL,   -- Set when enchantment is cast
        grey_moon      BOOLEAN NOT NULL,   -- Set when enchantment is cast
		focus          INTEGER NOT NULL,   -- Set when enchantment is cast
		caster_int     INTEGER NOT NULL,   -- Set when enchantment is cast
		caster_wis     INTEGER NOT NULL,   -- Set when enchantment is cast
		caster_luck    INTEGER NOT NULL,   -- Set when enchantment is cast
		hitroll        INTEGER NOT NULL,   -- Set when enchantment is id'd
		damroll        INTEGER NOT NULL,   -- Set when enchantment is id'd
		strength       INTEGER NOT NULL,   -- Set when enchantment is id'd
		intelligence   INTEGER NOT NULL,   -- Set when enchantment is id'd
		wisdom         INTEGER NOT NULL,   -- Set when enchantment is id'd
		dexterity      INTEGER NOT NULL,   -- Set when enchantment is id'd
		constitution   INTEGER NOT NULL,   -- Set when enchantment is id'd
		luck           INTEGER NOT NULL    -- Set when enchantment is id'd
      );

      PRAGMA user_version = 1;
    ]]
        dbCheckExecute(sql)
        version = 1
        Note("Updated DB to version " .. version)
    end

    assert(version == db_version)
end

-- DB exec functions are borrowed from aard_GMCP_mapper.xml
function dbCheck(code, msg, query)
    if code ~= sqlite3.OK and -- no error
    code ~= sqlite3.ROW and -- completed OK with another row of data
    code ~= sqlite3.DONE then -- completed OK, no more rows
        local err = msg .. "\n\nCODE: " .. code .. "\nQUERY: " .. query .. "\n"
        db:exec("ROLLBACK") -- rollback any transaction to unlock the database
        error(err, 3) -- show error in caller's context
    end -- if
end -- dbcheck

db_max_retries = 10
db_sleep_duration = 1
function dbCheckExecute(query)
    local code = db:exec(query)
    local count = 0
    while ((code == sqlite3.BUSY) or (code == sqlite3.LOCKED)) and (count < db_max_retries) do
        db:exec("ROLLBACK")
        local socket = require "socket"
        socket.sleep(db_sleep_duration)
        code = db:exec(query)
        count = count + 1
    end

    dbCheck(code, db:errmsg(), query)
end

function dbSave()
	Note("Saving DB")
    local opened = db:isopen()
    if not opened then
        dbOpen()
    end

    dbCheckExecute("PRAGMA wal_checkpoint(FULL);")

    if db:isopen() then
        db:close()
        if opened then
            dbOpen()
        end
    end
end

function dbClose()
    dbCheckExecute("PRAGMA optimize;")
    if db:isopen() then
        db:close()
    end
end

-- Enchantment functions --

local active_enchant = nil
local fizzle = false

function reset_active_enchant()
  active_enchant = {
	type = nil,
	success = nil,
	black_moon = nil,
	white_moon = nil,
	grey_moon = nil,
	focus = nil,
	caster_int = nil,
	caster_wis = nil,
	caster_luck = nil,
	hitroll = 0,
	damroll = 0,
	strength = 0,
	intelligence = 0,
	wisdom = 0,
	dexterity = 0,
	constitution = 0,
	luck = 0	
  }
  fizzle = false
end

function check_enchanters_focus()
  SendNoEcho("echo {enchant_check_focus}")
  SendNoEcho("aff")
  SendNoEcho("echo {/enchant_check_focus}")
end

function on_enchanters_focus_start(name, line, wildcards)
  EnableTriggerGroup("enchanters_focus", 1)
end

function on_enchanters_focus_end(name, line, wildcards)
  EnableTriggerGroup("enchanters_focus", 0)
  if active_enchant.focus == nil then
	active_enchant.focus = 0
  end
end

function on_capture_enchanters_focus(name, line, wildcards)
  active_enchant.focus = tonumber(wildcards["percent"])
end

function on_enchant_cast(type)
  reset_active_enchant()
  active_enchant.type = type

  -- Check moons
  set_moon_data()

  -- Check focus
  check_enchanters_focus()

  -- Check caster stats
  local char_stats = gmcp("char.stats")
  active_enchant.caster_int = char_stats.int
  active_enchant.caster_wis = char_stats.wis
  active_enchant.caster_luck = char_stats.luck
end

function set_moon_data()
  local rc, moon_data = CallPlugin("2e1f6126c7419c94e739611d", "isWhiteMoonUp")
  if rc ~= 0 then
    Note("Error checking white moon: " .. rc)
  end
  if moon_data then
	active_enchant.white_moon = true
  else
	active_enchant.white_moon = false
  end

  local rc, moon_data = CallPlugin("2e1f6126c7419c94e739611d", "isBlackMoonUp")
  if rc ~= 0 then
    Note("Error checking black moon: " .. rc)
  end
  if moon_data then
	active_enchant.black_moon = true
  else
	active_enchant.black_moon = false
  end

  local rc, moon_data = CallPlugin("2e1f6126c7419c94e739611d", "isGreyMoonUp")
  if rc ~= 0 then
    Note("Error checking grey moon: " .. rc)
  end
  if moon_data then
	active_enchant.grey_moon = true
  else
	active_enchant.grey_moon = false
  end
end

function on_enchant_cast_start(name, line, wildcards)
  Note("on_enchant_cast_start called")
  local type = wildcards["type"]
  if type == "illuminate" then
	on_enchant_cast("illuminate")
	EnableTriggerGroup("capture_illuminate", 1)
  elseif type == "resonate" then
	on_enchant_cast("resonate")
	EnableTriggerGroup("capture_resonate", 1)
  elseif type == "solidify" then
	on_enchant_cast("solidify")
	EnableTriggerGroup("capture_solidify", 1)
  end
  EnableTriggerGroup("capture_enchant_success", 1)
end

function on_enchant_success()
  Note("enchant success")
  active_enchant.success = true
end

function on_enchant_fizzle()
  Note("enchant fizzle")
  fizzle = true
end

function on_enchant_cast_end(name, line, wildcards)
  Note("on_enchant_cast_end called")
  local type = wildcards["type"]
  if type == "illuminate" then
	EnableTriggerGroup("capture_illuminate", 0)
  elseif type == "resonate" then
	EnableTriggerGroup("capture_resonate", 0)
  elseif type == "solidify" then
	EnableTriggerGroup("capture_solidify", 0)
  end
  EnableTriggerGroup("capture_enchant_success", 0)

  -- Recast if we fizzle
  if fizzle then
	local item = wildcards["item"]
    fizzle = false
	Execute("track " .. type .. " " .. item)
	return
  end

  -- If the enchantment failed to add stats, save now and finish up
  if not active_enchant.success then
    Note("enchant failure")
	SendNoEcho("echo {enchant_failure}")
  else
    Note("enchant success")
    id_enchant(type, wildcards["item"])
  end
end

function id_enchant(type, item)
  Note("id_enchant called")
  SendNoEcho("echo {" .. type .. "_id}")
  SendNoEcho("id " .. item)
  SendNoEcho("echo {/" .. type .. "_id}")
end

function on_enchant_failure()
  active_enchant.success = false
  display_active_enchant_data()
  save_enchant()
  reset_active_enchant()
end

function save_enchant()
  local sql = [[
	INSERT INTO enchantments (
	  type,
	  success,
	  black_moon,
	  white_moon,
	  grey_moon,
	  focus,
	  caster_int,
	  caster_wis,
	  caster_luck,
	  hitroll,
	  damroll,
	  strength,
	  intelligence,
	  wisdom,
	  dexterity,
	  constitution,
	  luck
	) VALUES (
	  ']] .. active_enchant.type .. [[',
	  ]] .. (active_enchant.success and "1" or "0") .. [[,
	  ]] .. (active_enchant.black_moon and "1" or "0") .. [[,
	  ]] .. (active_enchant.white_moon and "1" or "0") .. [[,
	  ]] .. (active_enchant.grey_moon and "1" or "0") .. [[,
	  ]] .. active_enchant.focus .. [[,
	  ]] .. active_enchant.caster_int .. [[,
	  ]] .. active_enchant.caster_wis .. [[,
	  ]] .. active_enchant.caster_luck .. [[,
	  ]] .. active_enchant.hitroll .. [[,
	  ]] .. active_enchant.damroll .. [[,
	  ]] .. active_enchant.strength .. [[,
	  ]] .. active_enchant.intelligence .. [[,
	  ]] .. active_enchant.wisdom .. [[,
	  ]] .. active_enchant.dexterity .. [[,
	  ]] .. active_enchant.constitution .. [[,
	  ]] .. active_enchant.luck .. [[
	);
  ]]

  dbCheckExecute(sql)
  SendNoEcho("echo {enchant_complete}")
end

function display_active_enchant_data()
  Note("Active enchant data:")
  for k, v in pairs(active_enchant) do
    if type(v) == "boolean" then
	  v = v and "true" or "false"
	end
	Note(k .. ": " .. v)
  end
end

function on_track_solidify(name, line, wildcards)
  local item = wildcards["item"]
  SendNoEcho("echo {enchant_cast_solidify_" .. item .. "}")
  SendNoEcho("c solidify " .. item)
  SendNoEcho("echo {/enchant_cast_solidify_" .. item .. "}")
end

function on_track_illuminate(name, line, wildcards)
  local item = wildcards["item"]
  SendNoEcho("echo {enchant_cast_illuminate_" .. item .. "}")
  SendNoEcho("c illuminate " .. item)
  SendNoEcho("echo {/enchant_cast_illuminate_" .. item .. "}")
end

function on_track_resonate(name, line, wildcards)
  local item = wildcards["item"]
  SendNoEcho("echo {enchant_cast_resonate_" .. item .. "}")
  SendNoEcho("c resonate " .. item)
  SendNoEcho("echo {/enchant_cast_resonate_" .. item .. "}")
end

function on_capture_solidify(name, line, wildcards)
  local type = wildcards["type"]
  local value = tonumber(wildcards["value"])

  if type == "Damage roll" then
	active_enchant.damroll = value
  elseif type == "Hit roll" then
	active_enchant.hitroll = value
  end
end

function on_capture_solidify_end(name, line, wildcards)
  EnableTriggerGroup("solidify_id", 0)
  finalize_enchant()
end

function on_capture_illuminate_end(name, line, wildcards)
  EnableTriggerGroup("illuminate_id", 0)
  finalize_enchant()
end

function on_capture_resonate_end(name, line, wildcards)
  EnableTriggerGroup("resonate_id", 0)
  finalize_enchant()
end

function finalize_enchant()
  display_active_enchant_data()
  save_enchant()
  reset_active_enchant()
end

function on_capture_illuminate(name, line, wildcards)
  local type = wildcards["type"]
  local value = tonumber(wildcards["value"])

  if type == "Luck" then
	active_enchant.luck = value
  elseif type == "Wisdom" then
	active_enchant.wisdom = value
  end
end

function on_capture_resonate(name, line, wildcards)
  local type = wildcards["type"]
  local value = tonumber(wildcards["value"])

  if type == "Strength" then
	active_enchant.strength = value
  elseif type == "Intelligence" then
	active_enchant.intelligence = value
  elseif type == "Wisdom" then
	active_enchant.wisdom = value
  elseif type == "Dexterity" then
	active_enchant.dexterity = value
  elseif type == "Constitution" then
	active_enchant.constitution = value
  elseif type == "Luck" then
	active_enchant.luck = value
  end
end

]]>
</script>

</muclient>
